# Crafting a Modern C++ Proxy Server: A Guide to Project Setup

![B2-Spirit](./image.jpeg)

In the world of software engineering, building a network proxy from scratch is a classic and rewarding challenge. It tests your understanding of networking, protocols, and performance. In this guide, we'll lay the groundwork for a simple, cross-platform HTTP proxy server using modern C++.

We won't be writing the full proxy logic today. Instead, we'll focus on the most critical, and often overlooked, part of any serious C++ project: **a robust and scalable project structure.**

We will cover:
1.  **Scaffolding the Project**: Creating a clean and logical directory structure.
2.  **Dependency Management**: Integrating `vcpkg` in manifest mode for easy package handling.
3.  **Build System Configuration**: Writing a clean and modern `CMakeLists.txt` file.
4.  **Putting It All Together**: Writing a simple "hello world" to test our setup.

---

### 1. The Blueprint: Project Scaffolding

A clean directory structure is the foundation of a maintainable project. It separates concerns and makes the codebase easier to navigate. For our proxy server, we'll use a standard layout:

```
proxy-server/
├── CMakeLists.txt        # Our main build script
├── vcpkg.json            # The vcpkg dependency manifest
│
├── include/              # Public headers (the "interface" of our library/app)
│   └── proxy/
│       └── platform.hpp  # Example header
│
└── src/                  # Source files (the "implementation")
    └── main.cpp
```

-   **`include/`**: This directory holds your public header files (`.hpp`). Any code that defines the *interface* of your application or libraries goes here. By placing them here, other parts of your project (or other projects) can easily include them.
-   **`src/`**: This directory contains the corresponding source files (`.cpp`). This is where the implementation details live.
-   **`CMakeLists.txt`**: The heart of our build system. It tells CMake how to compile and link our project.
-   **`vcpkg.json`**: This file declares our project's external dependencies. `vcpkg` will read this file and automatically download and build the libraries we need.

### 2. Painless Dependencies with vcpkg

Forgetting to `apt-get`, `brew install`, or manually build libraries is a common source of frustration in C++. `vcpkg` solves this. By using it in "manifest mode," we declare our dependencies in `vcpkg.json`, and CMake takes care of the rest.

Let's create our `vcpkg.json` and add `spdlog` for structured logging and `nlohmann-json` for configuration parsing—two excellent, header-only libraries perfect for our project.

**`vcpkg.json`**
```json
{
  "name": "proxy-server",
  "version-string": "0.1.0",
  "dependencies": [
    "spdlog",
    "nlohmann-json"
  ]
}
```

When CMake configures the project, it will now ensure these two libraries are available to be included in our code.

### 3. The Build System: Modern CMake

CMake can be intimidating, but a modern `CMakeLists.txt` is surprisingly clean and declarative. Let's build ours step by step.

**`CMakeLists.txt`**
```cmake
# 1. Set the minimum required CMake version and define the project
cmake_minimum_required(VERSION 3.23)
project(proxy LANGUAGES CXX)

# 2. Specify the C++ standard we want to use
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 3. Define our executable target
#    Add all your .cpp files here.
add_executable(proxy
    src/main.cpp
)

# 4. Tell CMake where to find our public header files.
#    This allows us to write #include "proxy/platform.hpp"
target_include_directories(proxy
    PUBLIC
        ${PROJECT_SOURCE_DIR}/include
)

# 5. Find the packages declared in vcpkg.json
#    The CONFIG keyword tells CMake to use the config files generated by vcpkg.
find_package(spdlog CONFIG REQUIRED)
find_package(nlohmann_json CONFIG REQUIRED)

# 6. Link our executable against the libraries we found
#    This handles both include directories and linker flags for these libraries.
target_link_libraries(proxy
    PRIVATE
        spdlog::spdlog
        nlohmann_json::nlohmann_json
)
```

**Key Concepts:**
-   **`target_include_directories`**: This is how we tell CMake that our `include` folder contains headers. Now, in `main.cpp`, we can use `#include "proxy/platform.hpp"` and CMake will provide the correct path to the compiler.
-   **`find_package`**: This command locates the dependency that `vcpkg` built.
-   **`target_link_libraries`**: This is the modern way to link dependencies. Instead of manually managing paths and library files, we link against the *imported target* (e.g., `spdlog::spdlog`). This automatically configures include paths and library linkage for us.

### 4. The First Spark: Hello, Proxy!

With the project structure in place, let's write a minimal `main.cpp` that uses `spdlog` to prove everything is wired correctly.

**`src/main.cpp`**
```cpp
#include <iostream>

// Include a library from vcpkg
#include <spdlog/spdlog.h>

// Include a header from our own 'include' directory
#include "proxy/platform.hpp"

int main(int argc, char* argv[]) {
    // Check for the port argument
    if (argc < 2) {
        spdlog::error("A port number is required.");
        spdlog::info("Usage: {} <port>", argv[0]);
        return 1;
    }

    // Use the spdlog library to print a message
    spdlog::set_level(spdlog::level::info);
    spdlog::info("Proxy server starting up...");
    spdlog::info("Attempting to listen on port {}", argv[1]);

    //
    // The core socket programming and HTTP parsing logic will go here.
    //

    spdlog::info("Proxy server shutting down.");

    return 0;
}
```

### 5. Building and Running

Because this project is set up with a `CMakePresets.json`, building is simple. You just need to tell CMake which preset to use.

```bash
# Configure the project using a preset (e.g., for MSVC + Ninja)
# This is when vcpkg downloads and installs dependencies.
cmake --preset msvc-ninja-debug

# Build the executable
cmake --build --preset msvc-ninja-debug

# Run it!
./build-msvc-ninja/proxy.exe 8080
```

You should see the output from `spdlog`:
```
[info] Proxy server starting up...
[info] Attempting to listen on port 8080
[info] Proxy server shutting down.
```

### Conclusion

We've successfully built a solid foundation for our C++ proxy server. While we haven't touched sockets or HTTP yet, we've accomplished something just as important: a clean, modern, and scalable project setup.

From here, you can confidently start building out the core proxy logic in the `src/` directory, knowing that your build system and dependency management are robust and ready to go.
---

## Part II: Accepting Connections

With a solid project structure, it's time to write our first piece of networking code. Our goal is to make the proxy application listen on a specific port and accept an incoming TCP connection. We'll verify this by attempting to connect to our proxy using the `curl` command.

We will cover:
1.  **Platform-Specific Setup**: Handling the differences between Winsock (Windows) and Berkeley Sockets (Linux/macOS).
2.  **Creating a Listening Socket**: Implementing the `socket`, `bind`, and `listen` flow.
3.  **Accepting a Client**: Writing the main server loop to `accept` a new connection.

### 6. A Cross-Platform Socket Header

Networking APIs are platform-specific. Windows uses the "Winsock" API which requires explicit initialization, while POSIX-compliant systems (like Linux and macOS) use the standard Berkeley Sockets API.

Let's update `platform.hpp` to handle these differences. This will be our single source of truth for platform-specific includes and definitions.

**`include/proxy/platform.hpp`**
```cpp
#pragma once

#ifdef _WIN32
    // Windows-specific headers and definitions
    #ifndef _WIN32_WINNT
    #define _WIN32_WINNT 0x0600 // Required for certain functions
    #endif
    #include <winsock2.h>
    #include <ws2tcpip.h>
    // Link against the Winsock library
    #pragma comment(lib, "ws2_32.lib")
#else
    // POSIX-specific headers and definitions
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <netdb.h>

    // Define Windows-specific types for cross-platform compatibility
    using SOCKET = int;
    const int INVALID_SOCKET = -1;
    const int SOCKET_ERROR = -1;
    #define closesocket(s) close(s)
#endif
```

This header now acts as a compatibility layer, allowing us to write more portable socket code.

### 7. The Socket Utility Module

Let's create the files for our socket utility functions. We need to tell CMake about the new `socket_utils.cpp` file.

**`CMakeLists.txt` (updated)**
```cmake
# ... (previous content) ...

add_executable(proxy
    src/main.cpp
    src/socket_utils.cpp  # <-- Add the new source file
)

# ... (rest of the file) ...
```

Now, let's create the header and source files.

**`include/proxy/socket_utils.hpp`**
```cpp
#pragma once
#include "proxy/platform.hpp"

namespace SocketUtils {
    // Initializes the underlying socket API (for Windows)
    void startup();
    // Cleans up the socket API (for Windows)
    void cleanup();
    // Creates a TCP socket that listens on the given port
    SOCKET create_listening_socket(int port);
}
```

**`src/socket_utils.cpp`**
```cpp
#include "proxy/socket_utils.hpp"
#include <spdlog/spdlog.h>
#include <stdexcept>
#include <string>

void SocketUtils::startup() {
#ifdef _WIN32
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        throw std::runtime_error("WSAStartup failed.");
    }
#endif
}

void SocketUtils::cleanup() {
#ifdef _WIN32
    WSACleanup();
#endif
}

SOCKET SocketUtils::create_listening_socket(int port) {
    SOCKET listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listen_socket == INVALID_SOCKET) {
        throw std::runtime_error("Failed to create socket.");
    }

    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listen_socket, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        closesocket(listen_socket);
        throw std::runtime_error("bind failed on port: " + std::to_string(port));
    }

    if (listen(listen_socket, SOMAXCONN) == SOCKET_ERROR) {
        closesocket(listen_socket);
        throw std::runtime_error("listen failed.");
    }

    return listen_socket;
}
```

### 8. The Main Server Loop

Now we can update `main.cpp` to use our new utility functions. It will initialize the socket API, create the listening socket, and enter an infinite loop to `accept` connections.

For now, it will simply log the incoming connection, close it immediately, and wait for the next one.

**`src/main.cpp` (updated)**
```cpp
#include <spdlog/spdlog.h>
#include <string>

#include "proxy/platform.hpp"
#include "proxy/socket_utils.hpp"

int main(int argc, char* argv[]) {
    if (argc < 2) {
        spdlog::error("A port number is required.");
        spdlog::info("Usage: {} <port>", argv[0]);
        return 1;
    }

    int port = std::stoi(argv[1]);

    try {
        SocketUtils::startup();
        SOCKET listen_socket = SocketUtils::create_listening_socket(port);
        spdlog::info("Server is listening on port {}", port);

        while (true) {
            sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);
            SOCKET client_socket = accept(listen_socket, (sockaddr*)&client_addr, &client_len);

            if (client_socket == INVALID_SOCKET) {
                spdlog::error("accept() failed.");
                continue; // Continue to the next attempt
            }

            // Log the new connection
            char client_ip[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
            spdlog::info("Accepted connection from {}:{}", client_ip, ntohs(client_addr.sin_port));

            // In Part III, we will forward data. For now, just close it.
            closesocket(client_socket);
            spdlog::info("Connection closed immediately.");
        }

        closesocket(listen_socket);
        SocketUtils::cleanup();

    } catch (const std::exception& e) {
        spdlog::critical("An error occurred: {}", e.what());
        SocketUtils::cleanup();
        return 1;
    }

    return 0;
}
```

### 9. Testing with `curl`

Let's test it! Rebuild the project and run the proxy server.

```bash
# Rebuild with the new source file
cmake --build --preset msvc-ninja-debug

# Run the server
./build-msvc-ninja/proxy.exe 8080
```
Your server is now running and waiting. In a **separate terminal**, run the following `curl` command. The `-x` flag tells `curl` to use our application as an HTTP proxy.

```bash
curl -x http://localhost:8080 http://example.com
```

**Expected Outcome:**

1.  **On the server terminal**, you will see logs like this:
    ```
    [info] Server is listening on port 8080
    [info] Accepted connection from 127.0.0.1:51234
    [info] Connection closed immediately.
    ```
2.  **On the `curl` terminal**, you will get an error. This is **expected**!
    ```
    curl: (56) Recv failure: Connection reset by peer
    ```
This error occurs because our server accepted the connection from `curl` but immediately closed it without sending any data back. This proves that our listening socket and `accept` loop are working correctly.

### Conclusion to Part II

We have successfully transitioned from a simple command-line application to a network server. Our application can now accept TCP connections from clients like `curl`.

In **Part III**, we will take the `client_socket` from the `accept` call and use it to read the incoming HTTP request, parse it, and begin the process of forwarding it to its final destination.
---

## Part III: Forwarding the Request

In Part II, we created a server that could accept a connection from `curl` and immediately close it. Now, we'll implement the core logic of the proxy: receiving a request, forwarding it to the intended destination, and sending the response back to the original client.

We will cover:
1.  **Concurrent Connections**: Using `std::thread` to handle multiple clients at once.
2.  **Basic HTTP Parsing**: Reading the client's request to find the destination host.
3.  **Connecting to the Destination**: Creating a new socket connection to the target server.
4.  **Bridging the Connections**: Relaying data between the client and the destination.

### 10. Handling Multiple Clients with Threads

Our current server can only handle one connection at a time. To make it useful, we need to handle multiple clients concurrently. While high-performance proxies use complex asynchronous I/O models, the simplest way to get started is to spawn a new thread for each incoming connection.

Let's begin by defining a function to handle a single client connection, and then update `main.cpp` to launch it in a new thread.

First, we need to add `<thread>` and `<vector>` to `main.cpp`. Then, we'll create the handler function.

**`src/main.cpp` (updated structure)**
```cpp
// ... includes ...
#include <thread>
#include <vector>

void handle_connection(SOCKET client_socket) {
    // This is where our forwarding logic will go
    spdlog::info("Handling connection in a new thread.");

    // For now, it will do nothing but close the socket.
    closesocket(client_socket);
    spdlog::info("Thread finished. Connection closed.");
}

int main(int argc, char* argv[]) {
    // ... setup code ...
    try {
        // ... socket creation ...
        spdlog::info("Server is listening on port {}", port);

        while (true) {
            // ... accept() logic ...

            if (client_socket == INVALID_SOCKET) {
                // ... error handling ...
                continue;
            }

            // ... log the accepted connection ...

            // Launch a new thread to handle the client
            // .detach() allows the thread to run independently.
            // For a real server, you'd manage threads more carefully (e.g., a thread pool).
            std::thread(handle_connection, client_socket).detach();
        }
        // ... cleanup ...
    } // ... catch ...
    return 0;
}
```

This change allows our `accept()` loop to immediately wait for the next connection while the newly created thread handles the previous one.

### 11. Parsing the HTTP Request

To know where to forward the request, we need to parse the `Host` header from the client's HTTP message. We'll create a simple parser for this.

First, add `src/http_parser.cpp` to `CMakeLists.txt`:
```cmake
add_executable(proxy
    src/main.cpp
    src/socket_utils.cpp
    src/http_parser.cpp   # <-- Add the new parser source
)
```

**`include/proxy/http_parser.hpp`**
```cpp
#pragma once
#include <string>
#include <unordered_map>

struct HttpRequest {
    std::string method;
    std::string host;
    std::string port = "80";
    std::string path;
    std::string raw_data;
};

// A very simple function to parse the host from a raw HTTP request
HttpRequest parse_host(char* buffer, int size);
```

**`src/http_parser.cpp`**
```cpp
#include "proxy/http_parser.hpp"
#include <spdlog/spdlog.h>
#include <string>
#include <sstream>

HttpRequest parse_host(char* buffer, int size) {
    HttpRequest req;
    req.raw_data = std::string(buffer, size);
    std::istringstream iss(req.raw_data);
    std::string line;

    // First line: GET http://example.com/ HTTP/1.1
    std::getline(iss, line);
    std::istringstream first_line_ss(line);
    first_line_ss >> req.method >> req.path >> req.version;

    // Subsequent lines for headers
    while (std::getline(iss, line) && line != "\r") {
        try {
            if (line.substr(0, 5) == "Host:") {
                std::string host_line = line.substr(6); // Skip "Host: "
                // Remove trailing '\r'
                host_line.erase(host_line.find_last_not_of(" \r\n\t") + 1);

                size_t colon_pos = host_line.find(':');
                if (colon_pos != std::string::npos) {
                    req.host = host_line.substr(0, colon_pos);
                    req.port = host_line.substr(colon_pos + 1);
                } else {
                    req.host = host_line;
                    req.port = "80"; // Default HTTP port
                }
                break; // Found host, no need to parse other headers
            }
        } catch(const std::exception& e) {
            spdlog::warn("Could not parse header line: {}", line);
        }
    }
    return req;
}
```

### 12. Connecting to the Destination and Relaying Data

Now we have all the pieces. We'll update our `handle_connection` function to perform the full proxy logic:
1.  Read the request from the client.
2.  Parse it to get the host.
3.  Connect to that host on a new socket.
4.  Send the original request to the destination.
5.  Enter a loop to shuttle data back and forth until the connection is closed.

**`src/main.cpp` (`handle_connection` updated)**
```cpp
#include "proxy/http_parser.hpp" // Add this include

void handle_connection(SOCKET client_socket) {
    char buffer[4096];
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

    if (bytes_received <= 0) {
        closesocket(client_socket);
        return;
    }

    HttpRequest request = parse_host(buffer, bytes_received);
    if (request.host.empty()) {
        spdlog::error("Could not parse host from request.");
        closesocket(client_socket);
        return;
    }

    spdlog::info("Thread [{}]: Forwarding request for host: {}:{}", std::this_thread::get_id(), request.host, request.port);

    // Get address info for the destination
    addrinfo hints = {}, *result;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    if (getaddrinfo(request.host.c_str(), request.port.c_str(), &hints, &result) != 0) {
        spdlog::error("getaddrinfo failed for host: {}", request.host);
        closesocket(client_socket);
        return;
    }

    // Create a new socket to connect to the destination
    SOCKET dest_socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (dest_socket == INVALID_SOCKET) {
        freeaddrinfo(result);
        closesocket(client_socket);
        return;
    }

    // Connect to the destination server
    if (connect(dest_socket, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
        spdlog::error("Failed to connect to destination: {}", request.host);
        freeaddrinfo(result);
        closesocket(dest_socket);
        closesocket(client_socket);
        return;
    }
    freeaddrinfo(result);

    // Forward the client's original request to the destination
    int bytes_sent = send(dest_socket, request.raw_data.c_str(), request.raw_data.length(), 0);
    if (bytes_sent == SOCKET_ERROR) {
        spdlog::error("send to destination failed.");
        closesocket(dest_socket);
        closesocket(client_socket);
        return;
    }

    // Bridge the connection: read from destination, write to client
    while ((bytes_received = recv(dest_socket, buffer, sizeof(buffer), 0)) > 0) {
        send(client_socket, buffer, bytes_received, 0);
    }

    // Cleanup
    spdlog::info("Thread [{}]: Closing connections.", std::this_thread::get_id());
    closesocket(dest_socket);
    closesocket(client_socket);
}

```

### 13. Testing the Full Proxy

Rebuild and run the server one last time.

```bash
# Rebuild with all new source files
cmake --build --preset msvc-ninja-debug

# Run the server
./build-msvc-ninja/proxy.exe 8080
```

Now, in your other terminal, run the `curl` command again:

```bash
curl -x http://localhost:8080 http://example.com
```

**This time, it should work!** You will see the full HTML of `example.com` printed in your terminal. On the server side, you will see logs detailing the connection and forwarding process.

### Final Conclusion

Congratulations! You have successfully built a basic, but functional, multi-threaded HTTP proxy server from scratch in modern C++. You have established a solid project structure, managed dependencies, configured a build system, and implemented the core networking logic for accepting, parsing, and forwarding requests.

From here, you can explore many advanced topics:
-   **Performance**: Replace the thread-per-client model with an asynchronous, event-driven architecture (using `select`, `poll`, or a library like Asio).
-   **HTTPS**: Implement the `CONNECT` method to handle encrypted HTTPS traffic.
-   **Caching**: Add a cache to store and serve frequently accessed resources.
-   **Robustness**: Improve error handling and resource management.
